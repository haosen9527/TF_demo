#include "/home/micros/catkin_new/src/demo/include/demo/network.h"
#include "/home/micros/catkin_new/src/demo/include/demo/vggnet_test.h"

////Network::Network(std::vector<Tensor> inputs, bool trainable)
////{
////  inputs=inputs;
////  this->trainable=true;
////}
//Network::~Network()
//{
//}
////std::vector<Tensor>  Network::load(std::string data_path,tensorflow::Session *session,tensorflow::ops::Save saver,bool ignore_missing)
////{

////}
//std::string * Network:: feed(std::string *args)
//{

//}
//std::string Network:: get_output(std::string layer)
//{

//}
////(prefix,id)
//std::string Network::get_unique_name(std::string prefix)
//{

//}
//std::string Network::make_var(std::string name,tensorflow::ops::Shape shape,bool initializer,bool trainable)
//{

//}
//bool Network::validate_padding(std::string padding)
//{

//}
////Tensor Network::conv(std::vector<Tensor> input, int k_h,int k_w,int c_o,int s_h,int s_w,std::string name, bool relu,std::string padding,int group, bool trainable)
////{

////}
//Tensor Network::relu(std::vector<Tensor> input,std::string name)
//{

//}
//Tensor Network::max_pool(std::vector<Tensor> input,int k_h,int k_w,int s_h,int s_w,std::string name, std::string padding)
//{

//}
//Tensor Network::avg_pool(std::vector<Tensor> input,int k_h,int k_w,int s_h,int s_w,std::string name, std::string padding)
//{

//}
//Tensor Network::roi_pool(std::vector<Tensor>input, int pooled_height,int pooled_width,int spatial_scale,std::string name)
//{

//}
//Tensor Network::proposal_layer(std::vector<Tensor>input, int _feat_stride,int anchor_scales,int cfg_key,std::string name)
//{

//}
//Tensor Network::anchor_target_layer(std::vector<Tensor> input,int _feat_stride,int anchor_scales,std::string name)
//{

//}
//Tensor Network::proposal_target_layer(std::vector<Tensor>  input,int classes, std::string name)
//{

//}
//Tensor Network::reshape_layer(std::vector<Tensor> input,int d,std::string name)
//{

//}
//Tensor Network::feature_extrapolating(std::vector<Tensor> input,int scales_base,int num_scale_base,int num_per_octave,std::string name)
//{

//}
//Tensor Network::lrn(std::vector<Tensor>  input,int radius,float alpha, float beta,std::string name,float bias)
//{

//}
//Tensor Network::concat(std::vector<Tensor> inputs, Tensor axis,std::string name)
//{

//}
Output Network::fc(Input input,int num_out,std::string name,bool relu,bool trainable)
  {
  }
//Tensor Network::softmax(std::vector<Tensor> input,std::string name)
//{

//}
//Tensor Network::dropout(std::vector<Tensor> input,Tensor keep_prob,std::string name)
//{

//}
int main()
{

}
